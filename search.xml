<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang闭包</title>
    <url>/2021/11/23/first/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>闭包是在上下文中引用了自由变量的函数，或者说是函数和其引用的环境的组合体</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := test(<span class="number">123</span>)</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<p>就这段代码而言，test返回的匿名函数会引用上下文环境变量x。当该函数在main中执行时，它依然可正确读取x的值，这种现象就称作闭包。</p>
<p>闭包是如何实现的？匿名函数被返回后，为何还能读取环境变量值？</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(&amp;x)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(&amp;x, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := test(<span class="number">123</span>)</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//0xc000088000</span></span><br><span class="line"><span class="comment">//0xc000088000 123</span></span><br></pre></td></tr></table></figure>
<p>通过输出指针，可以看出闭包直接引用了原环境变量。分析汇编代码，会看到返回的不仅仅是匿名函数，还包括引用的环境变量指针。所以说，闭包是函数和引用环境的组合更加贴切</p>
<h2 id="闭包的延迟求值"><a href="#闭包的延迟求值" class="headerlink" title="闭包的延迟求值"></a>闭包的延迟求值</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="built_in">println</span>(&amp;i, i)</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//将多个匿名函数加入切片s</span></span><br><span class="line">			<span class="built_in">println</span>(&amp;i, i)        <span class="comment">//第一次循环&#123;func(println(0xc000012018,0))&#125;，第二次循环&#123;func(println(0xc000012018,1)),func(println(0xc000012018,1))&#125;</span></span><br><span class="line">			                      <span class="comment">//第三次将2赋值给i，判断i不小于2，不进入循环体，但此时i的值已经被修改，</span></span><br><span class="line">								  <span class="comment">//因此第三次循环后&#123;func(println(0xc000012018,2)),func(println(0xc000012018,2))&#125;</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s                     <span class="comment">//返回匿名函数切片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> test() &#123;  <span class="comment">//迭代执行所有匿名函数</span></span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//0xc000012018 0</span></span><br><span class="line"><span class="comment">//0xc000012018 1</span></span><br><span class="line"><span class="comment">//0xc000012018 2</span></span><br><span class="line"><span class="comment">//0xc000012018 2</span></span><br></pre></td></tr></table></figure>


<ul>
<li>for循环复用局部变量i，即i变量的内存地址唯一，每次循环赋予不同的值</li>
<li>那么每次添加的匿名函数引用的自然是同一内存地址（同一变量）</li>
<li>添加操作仅仅是将匿名函数放入列表，并未执行</li>
<li>因此，当main执行这些函数时，他们读取的是环境变量i最后一次循环时的值。</li>
</ul>
<p>上述问题的解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次用不同的环境变量或传参复制，让各自闭包环境各不相同</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func test() []func() &#123;</span><br><span class="line">	var s []func()</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">		x := i</span><br><span class="line">		s = append(s, func() &#123;</span><br><span class="line">			println(&amp;x, x)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	for _, f := range test() &#123; //迭代执行所有匿名函数</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc000012018 0</span><br><span class="line">0xc000012020 1</span><br></pre></td></tr></table></figure>

<p>多个匿名函数引用同一环境变量，也会让事情变得更加复杂。任何的修改行为都会影响其他函数取值，在并发模式下可能需要做同步处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func test(x int) (func(), func()) &#123;</span><br><span class="line">	return func() &#123;</span><br><span class="line">			println(x)</span><br><span class="line">			x += 10</span><br><span class="line">		&#125;, func() &#123;</span><br><span class="line">			println(x)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a, b := test(100)</span><br><span class="line">	a()</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">110</span><br></pre></td></tr></table></figure>
<h2 id="闭包的优劣"><a href="#闭包的优劣" class="headerlink" title="闭包的优劣"></a>闭包的优劣</h2><p>闭包让我们不用传递参数就可读取或修改环境状态，当然也要为此付出额外代价。对于性能要求较高的场合，须慎重使用。</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
